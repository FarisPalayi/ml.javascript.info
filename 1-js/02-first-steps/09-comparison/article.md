# താരതമ്യപ്പെടുത്തൽ

ഗണിതത്തിൽ സംഖ്യകളെ പരസ്പരം താരതമ്യം ചെയ്യുന്നത് എങ്ങനെയെന്ന് നമുക്കറിയാം.

ജാവാസ്ക്രിപ്റ്റിൽ അത് ഇങ്ങനെയാണ് : 

- ഒന്ന് മറ്റൊന്നിനെക്കാൾ വലുത്/ചെറുത് :  <code>അ &gt; ആ</code>, <code>അ &lt; ആ</code> (<code>a &gt; b</code>, <code>a &lt; b</code>).
- ഒന്ന് മറ്റൊന്നിനെക്കാൾ വലുത്/ചെറുത് അല്ലെങ്കിൽ തുല്ല്യം : <code>അ &gt;= ആ</code>, <code>അ &lt;= ആ</code> (<code>a &gt;= b</code>, <code>a &lt;= b</code>).
- തുല്ല്യം/സമം : `അ === ആ`. ശ്രദ്ധിക്കുക രണ്ട് സമചിഹ്നം (`അ == ആ`) തുല്ല്യമാണോ എന്ന് പരിശോധിക്കാൻ ഉപയോഗിക്കുന്നു. എന്നാൽ ഒരു സമചിഹ്നം (`അ = ആ`) കൊണ്ടുദ്ദേശിക്കുന്നത് 'വാല്ല്യു കൊടുക്കുക (assignment)' എന്നാണ്.
- തുല്ല്യമല്ല : ഗണിതത്തിൽ ഇതിനുപയോഗിക്കുന്നത് <code>&ne;</code> ചിഹ്നമാണ്, എന്നാൽ ജാവാസ്ക്രിപ്റ്റിൽ അതിങ്ങനെയാണ് എഴുതുന്നത്: <code>അ != ആ</code> (<code>a != b</code>).
  
ഈ ലേഖനത്തിൽ പലതരം താരതമ്യപ്പെടുത്തലുകളെക്കുറിച്ചും, ജാവാസ്ക്രിപ്റ്റ് അവയെ എങ്ങനെയാണ് നിർമിക്കുന്നതെന്നും, നമ്മൾ പഠിക്കും. ജാവാസ്ക്രിപ്റ്റിൻ്റെ ചില പ്രധാനപ്പെട്ട 'അസ്വാഭാവിക പെരുമാറ്റങ്ങൾ' ഉൾപ്പെടെ.

ഇതിൻ്റെ അവസാനം ജാവാസ്ക്രിപ്റ്റിൻ്റെ ഇത്തരം അസ്വാഭാവിക പെരുമാറ്റങ്ങൾ കൊണ്ടുണ്ടാവുന്ന പ്രശ്നങ്ങളെ എങ്ങനെ ഒഴിവാക്കാം എന്നതിനെപ്പറ്റി നമുക്ക് നല്ല ധാരണ ലഭിക്കുന്നതാണ്.

## റിസൾട്ടായി ലഭിക്കുന്നത് ബൂലിയൻ ആയിരിക്കും

എല്ലാ താരതമ്യ ഓപറേറ്ററുകളും ഒരു ബൂലിയൻ വാല്ല്യുവാണ് റിട്ടേൺ ചെയ്യുന്നത്: 

- `true` -- അർത്ഥം "അതെ", "ശരി" അല്ലെങ്കിൽ "സത്യം".
- `false` -- അർത്ഥം "അല്ല", "തെറ്റ്", അല്ലെങ്കിൽ "സത്യമല്ല".

ഉദാഹരണത്തിന്:

```js run
alert( 2 > 1 );  // true (ശരി)
alert( 2 == 1 ); // false (തെറ്റ്)
alert( 2 != 1 ); // true (ശരി)
```

മറ്റേതൊരു വാല്ല്യുവും പോലെ താരതമ്യം ചെയ്ത് കിട്ടുന്ന റിസൾട്ടിനെ ഒരു വേരിയബിളിൽ കൊടുക്കാൻ(assign ചെയ്യാൻ) സാധിക്കും.

```js run
let result = 5 > 4; // റിസൾട്ടിനെ 'result' എന്ന വേരിയബിളിൽ സുക്ഷിക്കുന്നു (assign ചെയ്യുന്നു)
alert(result); // true
```
## സ്ട്രിങ്ങുകളെ താരതമ്യം ചെയ്യൽ

ഒരു സ്ട്രിംഗ് മറ്റൊന്നിനെക്കാൾ വലുതാണോ എന്നറിയാൻ ജാവാസ്ക്രിപ്റ്റ് "ഡിക്ഷണറി ഓർഡർ" (lexicographical order) ആണ് ഉപയോഗിക്കുന്നത്.

മറ്റൊരു തരത്തിൽ പറയുകയാണെങ്കിൽ, സ്ട്രിങ്ങുകളെ ഓരോ അക്ഷരം വീതം താരതമ്യം ചെയ്യുന്നു.

ഉദാഹരണത്തിന്:

```js run
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true

alert( 'ആ' > 'അ' ); // true
alert( 'കാക്കപ്പെണ്ണ്' > 'കാക്ക' ); // true
```

രണ്ട് സ്ട്രിങ്ങുകൾ തമ്മിൽ താരതമ്യം ചെയ്യാൻ ഉപയോഗിക്കുന്ന അൽഗോരിതം വളരെ ലളിതമാണ്:

1. രണ്ട് സ്ട്രിങ്ങിലെയും ആദ്യത്തെ അക്ഷരങ്ങൾ വീതം താരതമ്യം ചെയ്യുന്നു.
2. ആദ്യത്തെ സ്ട്രിങ്ങിലെ ആദ്യ അക്ഷരം രണ്ടാമത്തെ സ്ട്രിങ്ങിലെ ആദ്യ അക്ഷരത്തെക്കാൾ വലുതാണെങ്കിൽ, ആദ്യത്തെ സ്ട്രിങ്ങാണ് വലുത്. ഇനി തിരിച്ചാണെങ്കിൽ രണ്ടാമത്തെ സ്ട്രിങ്ങാണ് വലുത്. അത്രേയുള്ളു, കഴിഞ്ഞു.
3. ഇനി ആദ്യത്തെ രണ്ട് അക്ഷരങ്ങളും ഒന്നാണെങ്കിൽ, രണ്ട് സ്ട്രിങ്ങിലെയും രണ്ടാമത്തെ അക്ഷരമെടുത്ത് മുമ്പത്തെപ്പോലെ താരതമ്യം ചെയ്യും.
4. സ്ട്രിംഗ് തീരുന്നത് ഇത് തുടരും.
5. രണ്ട് സ്ട്രിങ്ങുകളും ഉൾക്കൊള്ളുന്നത് ഒരേ അക്ഷരങ്ങളാണെങ്കിൽ: സ്ട്രിങ്ങുകളുടെ നീളം തുല്ല്യമാണെങ്കിൽ അവ രണ്ടും തുല്ല്യമാണ്. അല്ലെങ്കിൽ നീളം കൂടിയ സ്ട്രിങ്ങാണ് വലുത്.

മുകളിലത്തെ ആദ്യത്തെ ഉദാഹരണത്തിൽ (`'Z' > 'A'`), താരതമ്യം ചെയ്യുമ്പോൾ ആദ്യത്തെ സ്റ്റെപ്പിൽ തന്നെ റിസൾട്ട് ലഭിക്കുന്നു.

എന്നാൽ രണ്ടാമത്തെ ഉദാഹരണത്തിൽ (`'Glow'` and `'Glee'`), റിസൾട്ട് ലഭിക്കാൻ കൂടുതൽ സ്റ്റെപ്പുകൾ ആവശ്യമായി വന്നു:

1. `G` യും `G` യും തുല്ല്യമാണ്.
2. `l` യും `l` യും തുല്ല്യമാണ്.
3. `o`, `e`യെക്കാൾ വലുതാണ്. താരതമ്യം ചെയ്യൽ ഇവിടെ നിർത്തുന്നു. ആദ്യത്തെ സ്ട്രിങ്ങാണ് വലുത്.

```smart header="Not a real dictionary, but Unicode order"
മുകളിലത്തെ താരതമ്യ അൽഗൊരിതം ഒരു ഡിക്ഷ്ണറിയിലോ ഫോൺ ബുക്കിലോ വാക്കുകൾ ക്രമീകരിക്കുന്നതിന് ഏകദേശം തുല്ല്യമാണ്. എങ്കിലും അത് അതുപോലെത്തന്നെയല്ല.

ഉദാഹരണത്തിന്, അക്ഷരം വലുതാണോ ചെറുതാണോ എന്നതിന് ഇതിൽ സ്വാധീനം ഉണ്ട്. അതായത് `"A"` യും `"a"` യും തുല്ല്യമല്ല. ഇതിൽ ഏതാണ് വലുത്? ചെറിയക്ഷരം `"a"`. അത് എന്തുകൊണ്ടോണെന്ന് വെച്ചാൽ ചെറിയക്ഷരങ്ങൾ ആണ് ജാവാസ്ക്രിപ്റ്റ് ഉപയോഗിക്കുന്ന ഇൻ്റേണൽ എൻകോഡിംഗ് ടേബിളിൽ(Unicode) മുകളിൽ വരുന്നത്. ഇതിനെക്കുറിച്ച് വിശദമായി നമ്മൾ <info:string> ചാപ്റ്ററിൽ പഠിക്കുന്നതാണ്.
```
## വ്യത്യസ്ത ടൈപ്പുകളെ(Data types) തമ്മിൽ താരതമ്യം ചെയ്യൽ

രണ്ട് വ്യത്യസ്ത വിഭാഗത്തിൽ പെട്ട വാല്യുകളെ തമ്മിൽ താരതമ്യം ചെയ്യുമ്പോൾ, ജാവാസ്ക്രിപ്റ്റ് അവയെ ആദ്യം ഒരു നമ്പറിലേക്ക് മാറ്റും.

ഉദാഹരണത്തിന്:

```js run
alert( '2' > 1 ); // true, സ്ട്രിംഗ് '2', നമ്പർ 2 ആയി മാറുന്നു.
alert( '01' == 1 ); // true, സ്ട്രിംഗ് '01' നമ്പർ 1 ആയി മാറുന്നു.
```
ബൂലിയൻ വാല്യുകളിൽ `true` `1` ആയും `false` `0` ആയും മാറുന്നു.

ഉദാഹരണത്തിന്:

```js run
alert( true == 1 ); // true
alert( false == 0 ); // true
```
```

````smart header="A funny consequence"
അതേ സമയം ഇതും സാധ്യമാണ്:

- രണ്ട് വാല്യുകളും തുല്യമാവാം.
- അതിലൊന്ന് `true` ഒരു ബൂലിയനായും, മറ്റൊന്ന് `false` ഒരു ബൂലിയനായും.


ഉദാഹരണത്തിന്:

``` js run
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```
ജാവാസ്ക്രിപ്റ്റിൻ്റെ ഭാഗത്തു നിന്നു നോക്കുമ്പോൾ ഈ റിസൾട്ട് സാധാരണമാണ്. ഒരു ഇക്വാലിറ്റി ചെക്ക് വാല്യുകളെ നേരിട്ട് നമ്പറിലേക്ക് മാറ്റുമ്പോൾ (അതായത് `"0"`, `0` ആയി മാറുന്നു), `Boolean` മറ്റു പല നിയമങ്ങളും അനുസരിച്ചാണ് ഇതു ചെയ്യുന്നത്.

## സംഗ്രഹം

- താരതമ്യ ഓപറേറ്ററുകൾ ഒരു ബൂലിയൻ വാല്യു (`true` or `false`) പുറത്ത് വിടുന്നു (റിട്ടേൺ ചെയ്യുന്നു).
- സ്ട്രിങ്ങുകൾ ഓരോ അക്ഷരം വീതമാണ് താരതമ്യം ചെയ്യപ്പെടുന്നത്. ഒരു ഡിക്ഷ്ണറിയിൽ വാക്കുകൾ ക്രമീകരിച്ചിരിക്കുന്നത് പോലെ.
- വ്യത്യസ്ത വിഭാഗങ്ങളിൽപ്പെട്ട(different data types) വാല്യൂകൾ തമ്മിൽ താരതമ്യം ചെയ്യുമ്പോൾ, അവ ആദ്യം ഒരു നമ്പറിലേക്ക് മാറ്റപ്പെടുന്നു.( സ്ട്രിക്റ്റ് ഇക്വാലിറ്റി ഓപറേറ്ററുകൾ(`===` and `!==`) ഉപയോഗിക്കുമ്പേൾ ഇത് ബാധകമാവുന്നില്ല ).
- `null`,`undefined` വാല്യുകൾ അവയെ പരസ്പരം പൂർണമാക്കുന്നു(`==`). അവ മറ്റൊരു വാല്യുവുമായും തുല്ല്യമാകുന്നില്ല.
- `null/undefined` വാല്ല്യു ലഭിക്കാൻ സാധ്യതയുള്ള വേരിയബ്ൾസുമായി `>` അല്ലെങ്കിൽ `<` പോലെയുള്ള താരതമ്യ ഓപറേറ്ററുകൾ ഉപയോഗിച്ച് താരതമ്യം ചെയ്യുമ്പോൾ ശ്രദ്ധിക്കുക. `null/undefined` വാല്ല്യുകളെ വെവ്വേറെ താരതമ്യം ചെയ്യുന്നതാവും ഉത്തമം.